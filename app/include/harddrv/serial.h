
#ifndef _SERIAL_H_
#define _SERIAL_H_

#include "portdefs.h"	
#include "modem.h"
#include "paradef.h"	
//#include "system.h"

#define MISITXDBUFLEN		1024
#define MISIRXDBUFLEN		1024 

#define CIPHEBAKBUFLEN		512
#define CIPHERTXDBUFLEN		1024
#define CIPHERRXDBUFLEN		1024 

#define NOREADCOUNT		20
#define NOHCARNUM		5

#define NOTIFYREANUM	10
#define NOTIFYWRITENUM	10

#define TIMERSUM		3		////定时器个数
#define RTSTIMERID		1

#define TXDON			TRUE
#define TXDOFF			FALSE

#define MODEM_CTS    	0x01
#define MODEM_DCD    	0x02
#define MODEM_DTR    	0x01
#define MODEM_RTS    	0x02

//定义串口IO控制命令类型
#define MODEM_SET		1	//设置串口MODEM有关输出状态，如RTS、DTR信号
#define MODEM_GET		2	//读取串口MODEM有关输入状态，如CTS、DCD信号
#define BAUD_SET		3	//串口波特率设置
#define BAUD_GET		4	//串口波特率读取
#define COM_PAR_SET		5	//串口通信参数设置，如数据位、停止位、校验位等
#define COM_PAR_GET		6	//串口通信参数获取，如数据位、停止位、校验位等
#define COM_CHAN_RESET	7	//串口通道复位
#define COM_TXD_END		8	//串口芯片发送数据结束，即数据送到线上，对于许多串口芯片发送数据
							//写入发送FIFO后并没有真正发送到线上，此时如果进行方向控制可能导致
							//发送数据不能完全发送。


#define MAXNORECIVE		(6*60*1000/SERIAL_TASK_TIMER)////没有接收也没有发送
#define MAXNOSEND		(6*1000 /SERIAL_TASK_TIMER)////缓冲区中有字符但没有发送出去

/*----------------------------------------------------------------------------------------*/
/* 定义逻辑串口到物理串口的映射表											              */
/*----------------------------------------------------------------------------------------*/
typedef struct serialmap{
	BYTE		nDriver;				/*该逻辑串口对应的物理串口类型*/
	BYTE		nChannel;				/*该逻辑串口在物理串口芯片的通道号*/
	BYTE		nChip;					/*该逻辑串口在物理串口中所属芯片号*/
	BYTE		nPort;					/*该逻辑串口在同类物理串口中的编号*/
}TSerialMap;


typedef struct  notifycnt{
	WORD		dwNotifyWrite;
	WORD		dwNotifyRead;
	WORD		dwNotifyRxdBreak;
	WORD		dwNotifyTxdBreak;
	WORD		dwNotifyCommBreak;
}TNotifyCount;


typedef struct serialbase{
    DWORD dwCmdAddr;		/*命令端口基址*/
    DWORD dwDataAddr;		/*数据端口基址*/
}SerialBaseAddr;


typedef struct timemsg{
	BOOL bTimer;
	WORD wTick;
	WORD wValue;
}SerialTimeMsg;


enum TIMERSTATUS
{
	NONEED, WAITENABLETXD, WAITOFFRTS
};

//串口类定义
class CSerial
{
	static CSerial* m_pSerialMap[MAX_SERIAL_NUM];

public:
		
	static CSerial* GetSerial(WORD wPort)
	{
		if(wPort >= MAX_SERIAL_NUM)
			return NULL;
			
		return m_pSerialMap[wPort];
	}
		
	static void ResetSerialMap()
	{
		for(int i=0; i < MAX_SERIAL_NUM; i++)
			m_pSerialMap[i] = NULL;
	}
		
	BOOL InitSerialMap()
	{
		WORD wLPort;
		wLPort = (WORD)m_dwPort;

		
		if(wLPort >= MAX_SERIAL_NUM)
			return FALSE;
			
		m_pSerialMap[wLPort] = this;
			
		return TRUE;
	}
		
	CSerial();
	
	~CSerial();
	
	BOOL 	     m_bOpend;			//串口打开标志
	BOOL 		 m_bTxdOnOff;		//串口发送控制当前状态标志
	BOOL 		 m_bRxdTail;		//接收报文结束标志
	BOOL 		 m_bNeedMessage;	//消息通知标志
	BOOL 		 m_bWriteContinue;	//应用层继续向串口写入数据标志
	BOOL 		 m_bNotify;			//消息通知标志
	BOOL 		 m_bNeedCtrlRTS;	//RTS方向控制标志
	BOOL 		 m_bRTSLogicHigh;	//RTS逻辑高有效标志
	BOOL 		 m_wRTSNoDelay;		//RTS不需要延时标志
	
	BYTE 		 m_bTxdMode;
	BYTE 		 m_bRxdMode;
	BYTE 		 m_bIntMode;
	
	DWORD 		 m_dwTagetID;		//消息发送对象ID
//	HANDLE 		 m_TaskID;			//
// 	DWORD 		 m_dwTimeID;
 	DWORD 		 m_dwBaseAddr;		//串口物理通道的操作基址
	WORD 		 m_dwNoReadCount;
	TCtlComm 	 m_CommCtrl;		//串口通道控制信息
	DWORD  		 m_dwPort;			//串口对应的端口号
//	DWORD  		 m_dwPortID;
	DWORD  		 m_dwFlag;			//应用层发送完整一帧数据的标志
	
	DWORD 		 m_dwBaud;			//串口通信波特率
//	WORD 		 m_wPortType;
	struct notifycnt notifyCount;
	TSerialPara  m_serialPara;		//串口参数
	struct serialmap m_PortInfo;	//串口通道映射表

	//通信异常统计
	DWORD		m_dwFECnt;			//帧出错(没有检测到停止位)
	DWORD		m_dwPECnt;			//校验出错
	DWORD		m_dwOECnt;			//过载出错

	DWORD		m_dwCounter;
	/*************************************************************************************
	* 串口类主任务，完成串口收发数据的管理															
	*************************************************************************************/
	void MainTask();

	/*************************************************************************************
	* 读取串口通道接收缓冲区内接收到的指定长度数据，一般供上层应用调用															
	*************************************************************************************/
	WORD ReadData(F_PBYTE pBuf, WORD wLen, DWORD dwFlag);
	
	/*************************************************************************************
	* 向串口通道发送缓冲区写入一定长度的数据，一般供上层应用调用															
	*************************************************************************************/
	WORD WriteData(F_PBYTE pBuf, WORD wLen, DWORD dwFlag);

	/*************************************************************************************
	* 取串口通道打开标志															
	*************************************************************************************/
	BOOL IsOpen();
	
	/*************************************************************************************
	* 串口通道打开															
	*************************************************************************************/
	STATUS OpenComm(WORD wRxdLen, WORD wTxdLen);

	/*************************************************************************************
	* 设置串口控制信息															
	*************************************************************************************/
	STATUS SerialControl(TCtlComm* pCtrl);

	/*************************************************************************************
	* 串口通道发送控制															
	*************************************************************************************/
	void SerialTxdCtr(BOOL bOnOff);

	/*************************************************************************************
	* 根据通信速率序号获取串口通信速率，并计算接收结束最大时间长度															
	*************************************************************************************/
	void GetBaud();

	/*************************************************************************************
	* 初始化串口类通信参数，如串口类型、方向控制等															
	*************************************************************************************/
	void InitPara();

	/*************************************************************************************
	* 根据标志复位串口通道类，可能为发送缓冲区、接收缓冲区或整个串口通道															
	*************************************************************************************/
	void ResetSerial(DWORD dwFlag);
	
	/*************************************************************************************
	* 复位串口通道类，并关闭串口物理通道的发送和接收															
	*************************************************************************************/
	void ResetSerial();

	/*************************************************************************************
	* 串口类主任务，完成串口收发数据的管理															
	*************************************************************************************/
	WORD GetCanSendNum();	

	/*************************************************************************************
	* 取可以向串口通道发送缓冲区写入的字节个数															
	*************************************************************************************/
	WORD GetCanWriteNum();	

	/*************************************************************************************
	* 从串口通道发送缓冲区读取一定长度的数据，一般供底层驱动调用															
	*************************************************************************************/
	WORD ReadFromBuf(F_PBYTE pBuf, WORD wLen);

	/*************************************************************************************
	* 从串口通道发送缓冲区读取一定长度的数据，一般供底层驱动调用															
	*************************************************************************************/
	WORD ReadFromBuf(PBYTE pBuf, WORD wOffset,WORD wLen);
	
	/*************************************************************************************
	* 向串口通道接收缓冲区写入一定长度的数据，一般供底层驱动调用															
	*************************************************************************************/
	WORD WriteToBuf(F_PBYTE pBuf, WORD wLen);

	WORD GetTxdWritePtr();
	WORD GetRxdWritePtr();
	WORD ReadFromTxdBuf(BYTE* pBuf, WORD wOffset,WORD wLen);
	WORD ReadFromRxdBuf(BYTE* pBuf, WORD wOffset,WORD wLen);
	
	WORD ReadNewTxdData(BYTE* pBuf, WORD wOffset,WORD wLen);
	WORD ReadNewRxdData(BYTE* pBuf, WORD wOffset,WORD wLen);
	
private:
	WORD 	 m_dwNoRxdTime;			//接收报文结束时间计数
	WORD 	 m_dwMaxNoRxdTime;		//接收报文结束门限时间

	//最初设计用来监视串口长时间无法通信时进行串口复位操作，但是没有使用
	WORD 	 m_dwNoRecive;			//无接收数据时间累计
	WORD 	 m_dwNoSend;			//无发送数据时间累计
//	WORD 	 m_wResetCnt;			//串口复位计数

	//for RTS control	
	WORD 	 m_wRTSOnDelay;			//RTS打开时间限值
	WORD 	 m_wRTSOffDelay;		//RTS关闭时间限值
	
	TIMERSTATUS  timerStatus;		//串口定时器当前状态

//	WORD m_dwNoRunCount;
//	WORD m_wAppID;
//	WORD m_bNoReadCount;
	WORD m_wRxdWritePtr;			//串口接收缓冲区写指针
	WORD m_wRxdReadPtr;				//串口接收缓冲区读指针
	WORD m_wTxdWritePtr;			//串口发送缓冲区写指针
	WORD m_wTxdReadPtr;				//串口发送缓冲区读指针
	F_PBYTE m_TxdBuf;				//串口发送缓冲区
	F_PBYTE m_RxdBuf;				//串口接收缓冲区
	WORD m_wMaxTxdLen;				//串口发送缓冲区长度
	WORD m_wMaxRxdLen;				//串口接收缓冲区长度
	
	struct timemsg timeMsg[TIMERSUM];	//串口内部定时器

	/*************************************************************************************
	* 检查各个串口通道的通信情况，并并根据情况通知对应的应用层任务。															
	*************************************************************************************/
	void NotifyTask();

	/*************************************************************************************
	* 发送检查任务，当发送缓冲区有数据时，在对应串口允许的情况下触发发送；当需要软件
	* 方式控制RTS信号时完成RTS信号的带延时控制
	*************************************************************************************/
	void CheckTxdTask();
	
	/*************************************************************************************
	* 接收帧结束检查															
	*************************************************************************************/
	void DetectFrameTailTask();

	/*************************************************************************************
	* 消息通知处理															
	*************************************************************************************/
	STATUS NotifyToUse(WORD wMsg, WORD wLen, DWORD dwFlag);
	
	/*************************************************************************************
	* 取串口类接收缓冲区字符数															
	*************************************************************************************/
	WORD GetLeftRxdNum();

	/*************************************************************************************
	* 累加发送空闲及串口通道通信空闲计数															
	*************************************************************************************/
	void SetWriteMask();
	
	/*************************************************************************************
	* 清除发送空闲及串口通道通信空闲计数															
	*************************************************************************************/
	void ClearWriteMask();
	
	/*************************************************************************************
	* 累加接收空闲及串口通道通信空闲计数															
	*************************************************************************************/
	void SetReadMask();
	
	/*************************************************************************************
	* 清除接收空闲及串口通道通信空闲计数															
	*************************************************************************************/
	void ClearReadMask();
	
	/*************************************************************************************
	* 清接收帧尾判断标志															
	*************************************************************************************/
	void ClearFameTail();
	
	/*************************************************************************************
	* 根据参数计算RTS方向控制延时时间															
	*************************************************************************************/
	void GetRtsDelay();
	
	/*************************************************************************************
	* 串口类内部定时处理过程															
	*************************************************************************************/
	void MyTimerTask();
	
	/*************************************************************************************
	* 串口类内部定时器创建															
	*************************************************************************************/
	BOOL MySetTimer(BYTE bTimerID, WORD wMSecond);

	/*************************************************************************************
	* 串口类内部定时器删除															
	*************************************************************************************/
	BOOL MyKillTimer(BYTE bTimerID);

	/*************************************************************************************
	* 串口类内部定时处理，主要完成串口控制信号的软件定时控制															
	*************************************************************************************/
	void MyOnTimer(BYTE bTimerID);
	
	/*************************************************************************************
	* 向对应串口物理通道写入一个字节的发送数据，一般供串口驱动调用以触发发送中断															
	*************************************************************************************/
	void WriteAChar();
	
	/*************************************************************************************
	* 检查串口发送数据是否真正发送结束															
	*************************************************************************************/
	BOOL IsTxdEnd();
	
};


void NumToBaud(WORD wNum, DWORD *dwBaud);

void BaudToNum(DWORD dwBaud, BYTE *byNum);

#endif
